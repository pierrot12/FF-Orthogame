require('dotenv').config();
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');

const app = express();

console.log('üöÄ D√©marrage du serveur...');

app.use(cors());
app.use(express.json());

const MONGODB_URI = process.env.MONGODB_URI || 'your_mongodb_atlas_connection_string';

console.log('üì° Connexion √† MongoDB...');
mongoose.connect(MONGODB_URI, {
  useNewUrlParser: true,
  useUnifiedTopology: true
})
.then(() => {
  console.log('‚úÖ MongoDB connect√© avec succ√®s !');
  createDefaultAdmin();
})
.catch((err) => console.error('‚ùå Erreur MongoDB:', err.message));

// Schemas
const userSchema = new mongoose.Schema({
  username: { type: String, required: true, unique: true },
  password: { type: String, required: true },
  isAdmin: { type: Boolean, default: false },
  createdAt: { type: Date, default: Date.now },
  badges: { type: [String], default: [] },
  stats: {
    totalExercises: { type: Number, default: 0 },
    perfectScores: { type: Number, default: 0 },
    consecutiveDays: { type: Number, default: 0 },
    lastLoginDate: { type: Date, default: null },
    totalWords: { type: Number, default: 0 },
    correctWords: { type: Number, default: 0 },
    simpleWordsCorrect: { type: Number, default: 0 },
    verbsCorrect: { type: Number, default: 0 },
    presentCorrect: { type: Number, default: 0 },
    futurCorrect: { type: Number, default: 0 },
    imparfaitCorrect: { type: Number, default: 0 },
    passeComposeCorrect: { type: Number, default: 0 },
    consecutiveCorrect: { type: Number, default: 0 },
    bestStreak: { type: Number, default: 0 }
  }
}, { versionKey: false }); // ‚úÖ FIX: D√©sactive le versioning qui cause le probl√®me

const wordSchema = new mongoose.Schema({
  text: { type: String, required: true },
  type: { type: String, enum: ['simple', 'verb'], required: true },
  conjugation: { 
    type: String, 
    enum: ['present', 'futur', 'imparfait', 'passe_compose', null], 
    default: null 
  },
  conjugatedForms: {
    type: {
      je: { type: String, default: '' },
      tu: { type: String, default: '' },
      il: { type: String, default: '' },
      nous: { type: String, default: '' },
      vous: { type: String, default: '' },
      ils: { type: String, default: '' }
    },
    required: false,
    default: null
  },
  autoGenerated: { type: Boolean, default: false }
});

const exerciseSchema = new mongoose.Schema({
  name: { type: String, required: true },
  words: [wordSchema],
  createdBy: { type: String, required: true },
  createdAt: { type: Date, default: Date.now }
});

const scoreSchema = new mongoose.Schema({
  username: { type: String, required: true },
  exerciseName: { type: String, required: true },
  score: { type: Number, required: true },
  totalWords: { type: Number, required: true },
  correctWords: { type: Number, required: true },
  date: { type: Date, default: Date.now }
});

// Models
const User = mongoose.model('User', userSchema);
const Exercise = mongoose.model('Exercise', exerciseSchema);
const Score = mongoose.model('Score', scoreSchema);

// Cr√©er un compte admin par d√©faut
async function createDefaultAdmin() {
  try {
    const adminExists = await User.findOne({ username: 'admin' });
    if (!adminExists) {
      const admin = new User({
        username: 'admin',
        password: 'admin123',
        isAdmin: true
      });
      await admin.save();
      console.log('‚úÖ Compte administrateur par d√©faut cr√©√© (admin/admin123)');
    } else {
      console.log('‚ÑπÔ∏è Compte administrateur d√©j√† existant');
    }
  } catch (error) {
    console.error('‚ùå Erreur cr√©ation admin par d√©faut:', error.message);
  }
}

// Routes

// Route de test
app.get('/', (req, res) => {
  res.json({ message: 'API Orthographe Game - Backend op√©rationnel !' });
});

// Users
app.post('/api/users/login', async (req, res) => {
  try {
    const { username, password } = req.body;
    
    if (!username || username.trim() === '') {
      return res.status(400).json({ error: 'Le nom d\'utilisateur est requis' });
    }
    
    if (!password || password.trim() === '') {
      return res.status(400).json({ error: 'Le mot de passe est requis' });
    }
    
    let user = await User.findOne({ username, password });
    
    if (!user) {
      return res.status(401).json({ error: 'Nom d\'utilisateur ou mot de passe incorrect' });
    }
    
    console.log(`üë§ Connexion utilisateur: ${username} (Admin: ${user.isAdmin})`);
    res.json(user);
  } catch (error) {
    console.error('‚ùå Erreur login:', error.message);
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/users/create', async (req, res) => {
  try {
    const { username, password, isAdmin, createdBy } = req.body;
    
    if (!username || username.trim() === '') {
      return res.status(400).json({ error: 'Le nom d\'utilisateur est requis' });
    }
    
    if (!password || password.trim() === '') {
      return res.status(400).json({ error: 'Le mot de passe est requis' });
    }
    
    const existingUser = await User.findOne({ username });
    if (existingUser) {
      return res.status(409).json({ error: 'Ce nom d\'utilisateur existe d√©j√†' });
    }
    
    const user = new User({ 
      username, 
      password,
      isAdmin: isAdmin || false 
    });
    await user.save();
    console.log(`‚úÖ Nouvel utilisateur cr√©√©: ${username} (Admin: ${isAdmin}) par ${createdBy}`);
    res.json(user);
  } catch (error) {
    console.error('‚ùå Erreur cr√©ation utilisateur:', error.message);
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/users', async (req, res) => {
  try {
    const users = await User.find();
    res.json(users);
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration users:', error.message);
    res.status(500).json({ error: error.message });
  }
});

app.delete('/api/users/:id', async (req, res) => {
  try {
    await User.findByIdAndDelete(req.params.id);
    console.log(`üóëÔ∏è Utilisateur supprim√©: ${req.params.id}`);
    res.json({ message: 'Utilisateur supprim√©' });
  } catch (error) {
    console.error('‚ùå Erreur suppression utilisateur:', error.message);
    res.status(500).json({ error: error.message });
  }
});

// Exercises
app.post('/api/exercises', async (req, res) => {
  try {
    const { name, words, createdBy } = req.body;
    
    if (!name || !words || words.length === 0) {
      return res.status(400).json({ error: 'Nom et mots requis' });
    }
    
    const exercise = new Exercise({ name, words, createdBy });
    await exercise.save();
    console.log(`‚úÖ Exercice cr√©√©: ${name} (${words.length} mots)`);
    res.json(exercise);
  } catch (error) {
    console.error('‚ùå Erreur cr√©ation exercice:', error.message);
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/exercises', async (req, res) => {
  try {
    const exercises = await Exercise.find().sort({ createdAt: -1 });
    res.json(exercises);
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration exercices:', error.message);
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/exercises/:id', async (req, res) => {
  try {
    const exercise = await Exercise.findById(req.params.id);
    if (!exercise) {
      return res.status(404).json({ error: 'Exercice non trouv√©' });
    }
    res.json(exercise);
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration exercice:', error.message);
    res.status(500).json({ error: error.message });
  }
});

app.put('/api/exercises/:id', async (req, res) => {
  try {
    const { name, words } = req.body;
    
    if (!name || !words || words.length === 0) {
      return res.status(400).json({ error: 'Nom et mots requis' });
    }
    
    const exercise = await Exercise.findByIdAndUpdate(
      req.params.id,
      { name, words },
      { new: true }
    );
    console.log(`‚úÖ Exercice modifi√©: ${name} (${words.length} mots)`);
    res.json(exercise);
  } catch (error) {
    console.error('‚ùå Erreur modification exercice:', error.message);
    res.status(500).json({ error: error.message });
  }
});

app.delete('/api/exercises/:id', async (req, res) => {
  try {
    await Exercise.findByIdAndDelete(req.params.id);
    console.log(`üóëÔ∏è Exercice supprim√©: ${req.params.id}`);
    res.json({ message: 'Exercice supprim√©' });
  } catch (error) {
    console.error('‚ùå Erreur suppression exercice:', error.message);
    res.status(500).json({ error: error.message });
  }
});

// Scores - VERSION CORRIG√âE
app.post('/api/scores', async (req, res) => {
  try {
    const { username, exerciseName, score, totalWords, correctWords, results } = req.body;
    
    if (!username || !exerciseName || score === undefined) {
      return res.status(400).json({ error: 'Donn√©es incompl√®tes' });
    }
    
    // Sauvegarder le score
    const newScore = new Score({ 
      username, 
      exerciseName, 
      score, 
      totalWords, 
      correctWords 
    });
    await newScore.save();
    console.log(`‚úÖ Score sauvegard√© dans la base de donn√©es`);
    
    // ‚úÖ FIX: Utiliser findOneAndUpdate au lieu de save() pour √©viter les conflits de version
    const user = await User.findOne({ username });
    if (user) {
      const updateData = {
        $inc: {
          'stats.totalExercises': 1,
          'stats.totalWords': totalWords,
          'stats.correctWords': correctWords
        }
      };
      
      // Incrementer perfectScores si score est 100
      if (score === 100) {
        updateData.$inc['stats.perfectScores'] = 1;
      }
      
      // Calculer les jours cons√©cutifs
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const lastLogin = user.stats?.lastLoginDate ? new Date(user.stats.lastLoginDate) : null;
      
      let consecutiveDays = user.stats?.consecutiveDays || 0;
      if (lastLogin) {
        lastLogin.setHours(0, 0, 0, 0);
        const diffDays = Math.floor((today - lastLogin) / (1000 * 60 * 60 * 24));
        
        if (diffDays === 1) {
          consecutiveDays = consecutiveDays + 1;
        } else if (diffDays > 1) {
          consecutiveDays = 1;
        }
      } else {
        consecutiveDays = 1;
      }
      
      updateData.$set = {
        'stats.consecutiveDays': consecutiveDays,
        'stats.lastLoginDate': new Date()
      };
      
      // Analyser les r√©sultats d√©taill√©s
      if (results && Array.isArray(results)) {
        let simpleWordsCorrect = 0;
        let verbsCorrect = 0;
        let presentCorrect = 0;
        let futurCorrect = 0;
        let imparfaitCorrect = 0;
        let passeComposeCorrect = 0;
        let currentStreak = 0;
        let bestStreak = user.stats?.bestStreak || 0;
        
        results.forEach(result => {
          if (result.isCorrect) {
            currentStreak++;
            if (currentStreak > bestStreak) {
              bestStreak = currentStreak;
            }
            
            if (result.word?.type === 'simple') {
              simpleWordsCorrect++;
            } else if (result.word?.type === 'verb') {
              verbsCorrect++;
              
              switch(result.word?.conjugation) {
                case 'present': presentCorrect++; break;
                case 'futur': futurCorrect++; break;
                case 'imparfait': imparfaitCorrect++; break;
                case 'passe_compose': passeComposeCorrect++; break;
              }
            }
          } else {
            currentStreak = 0;
          }
        });
        
        updateData.$inc['stats.simpleWordsCorrect'] = simpleWordsCorrect;
        updateData.$inc['stats.verbsCorrect'] = verbsCorrect;
        updateData.$inc['stats.presentCorrect'] = presentCorrect;
        updateData.$inc['stats.futurCorrect'] = futurCorrect;
        updateData.$inc['stats.imparfaitCorrect'] = imparfaitCorrect;
        updateData.$inc['stats.passeComposeCorrect'] = passeComposeCorrect;
        
        if (bestStreak > (user.stats?.bestStreak || 0)) {
          updateData.$set['stats.bestStreak'] = bestStreak;
        }
      }
      
      // ‚úÖ FIX: Mettre √† jour l'utilisateur avec findOneAndUpdate
      const updatedUser = await User.findOneAndUpdate(
        { username },
        updateData,
        { new: true }
      );
      
      // V√©rifier les nouveaux badges
      const newBadges = checkBadges(updatedUser);
      if (newBadges.length > 0) {
        // Ajouter les nouveaux badges
        await User.findOneAndUpdate(
          { username },
          { $addToSet: { badges: { $each: newBadges } } }
        );
        console.log(`üèÜ ${newBadges.length} nouveau(x) badge(s) d√©bloqu√©(s) pour ${username}`);
        return res.json({ score: newScore, newBadges });
      }
      
      console.log(`üìä Stats mises √† jour pour ${username}`);
    }
    
    console.log(`üèÜ Score enregistr√©: ${username} - ${score}% (${exerciseName})`);
    res.json({ score: newScore, newBadges: [] });
  } catch (error) {
    console.error('‚ùå Erreur enregistrement score:', error.message);
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/scores', async (req, res) => {
  try {
    const scores = await Score.find().sort({ date: -1 });
    res.json(scores);
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration scores:', error.message);
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/scores/user/:username', async (req, res) => {
  try {
    const scores = await Score.find({ username: req.params.username }).sort({ date: -1 });
    res.json(scores);
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration scores utilisateur:', error.message);
    res.status(500).json({ error: error.message });
  }
});

// Fonction de d√©tection des badges
function checkBadges(user) {
  const newBadges = [];
  const stats = user.stats || {};
  const currentBadges = user.badges || [];
  
  // Badges de progression
  if (stats.totalExercises >= 1 && !currentBadges.includes('graine')) {
    newBadges.push('graine');
  }
  if (stats.totalExercises >= 5 && !currentBadges.includes('pousse')) {
    newBadges.push('pousse');
  }
  if (stats.totalExercises >= 20 && !currentBadges.includes('arbre')) {
    newBadges.push('arbre');
  }
  if (stats.totalExercises >= 50 && !currentBadges.includes('maitre')) {
    newBadges.push('maitre');
  }
  if (stats.totalExercises >= 100 && !currentBadges.includes('empereur')) {
    newBadges.push('empereur');
  }
  
  // Badges de performance
  if (stats.totalExercises >= 1 && !currentBadges.includes('etoile1')) {
    newBadges.push('etoile1');
  }
  if (stats.perfectScores >= 1 && !currentBadges.includes('sansfaute')) {
    newBadges.push('sansfaute');
  }
  if (stats.perfectScores >= 5 && !currentBadges.includes('tireur')) {
    newBadges.push('tireur');
  }
  if (stats.perfectScores >= 10 && !currentBadges.includes('perfection')) {
    newBadges.push('perfection');
  }
  
  // Badges de pers√©v√©rance
  if (stats.consecutiveDays >= 2 && !currentBadges.includes('flamme1')) {
    newBadges.push('flamme1');
  }
  if (stats.consecutiveDays >= 5 && !currentBadges.includes('flamme2')) {
    newBadges.push('flamme2');
  }
  if (stats.consecutiveDays >= 10 && !currentBadges.includes('flamme3')) {
    newBadges.push('flamme3');
  }
  if (stats.consecutiveDays >= 7 && !currentBadges.includes('arcenciel')) {
    newBadges.push('arcenciel');
  }
  if (stats.consecutiveDays >= 30 && !currentBadges.includes('foudre')) {
    newBadges.push('foudre');
  }
  
  // Badges sp√©cialis√©s
  if (stats.simpleWordsCorrect >= 20 && !currentBadges.includes('roimots')) {
    newBadges.push('roimots');
  }
  if (stats.verbsCorrect >= 20 && !currentBadges.includes('jongleur')) {
    newBadges.push('jongleur');
  }
  if (stats.presentCorrect >= 10 && !currentBadges.includes('acrobate')) {
    newBadges.push('acrobate');
  }
  if (stats.presentCorrect >= 5 && stats.futurCorrect >= 5 && 
      stats.imparfaitCorrect >= 5 && stats.passeComposeCorrect >= 5 && 
      !currentBadges.includes('voyageur')) {
    newBadges.push('voyageur');
  }
  
  // Badges de d√©fi
  if (stats.bestStreak >= 100 && !currentBadges.includes('cerveau')) {
    newBadges.push('cerveau');
  }
  
  return newBadges;
}

// M√©tadonn√©es des badges
const badgeMetadata = {
  graine: { name: 'üå± Graine d\'orthographe', description: 'Premier exercice r√©ussi' },
  pousse: { name: 'üåø Pousse prometteuse', description: '5 exercices r√©ussis' },
  arbre: { name: 'üå≥ Arbre de la connaissance', description: '20 exercices r√©ussis' },
  maitre: { name: 'üèÜ Ma√Ætre des mots', description: '50 exercices r√©ussis' },
  empereur: { name: 'üëë Empereur de l\'orthographe', description: '100 exercices r√©ussis' },
  
  etoile1: { name: '‚≠ê Premi√®re √©toile', description: 'Terminer un exercice' },
  sansfaute: { name: '‚ú® Sans faute !', description: 'Premier score de 100%' },
  tireur: { name: 'üéØ Tireur d\'√©lite', description: '5 exercices √† 100%' },
  perfection: { name: 'üíé Perfection incarn√©e', description: '10 exercices √† 100%' },
  
  flamme1: { name: 'üî• Premi√®re flamme', description: '2 jours cons√©cutifs' },
  flamme2: { name: 'üî•üî• S√©rie en feu', description: '5 jours cons√©cutifs' },
  flamme3: { name: 'üî•üî•üî• Incendie de motivation', description: '10 jours cons√©cutifs' },
  arcenciel: { name: 'üåà Arc-en-ciel', description: '7 jours d\'affil√©e' },
  foudre: { name: '‚ö° Foudre d\'√©nergie', description: '30 jours cons√©cutifs' },
  
  roimots: { name: 'üìñ Roi des mots simples', description: '20 mots simples parfaits' },
  jongleur: { name: 'üé≠ Jongleur de verbes', description: '20 verbes parfaits' },
  acrobate: { name: 'üé™ Acrobate du pr√©sent', description: '10 verbes au pr√©sent parfaits' },
  voyageur: { name: '‚è∞ Voyageur du temps', description: 'Ma√Ætriser tous les temps' },
  
  cerveau: { name: 'üß† Cerveau d\'acier', description: '100 mots corrects d\'affil√©e' }
};

app.get('/api/badges/metadata', (req, res) => {
  res.json(badgeMetadata);
});

// D√©marrage du serveur
const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
  console.log(`‚úÖ Serveur d√©marr√© sur le port ${PORT}`);
  console.log(`üåê API disponible sur http://localhost:${PORT}/api`);
  console.log(`üìù Test: http://localhost:${PORT}/`);
});