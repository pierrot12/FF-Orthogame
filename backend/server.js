require('dotenv').config();
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');

const app = express();

console.log('ğŸš€ DÃ©marrage du serveur...');

app.use(cors());
app.use(express.json());

const MONGODB_URI = process.env.MONGODB_URI || 'your_mongodb_atlas_connection_string';

console.log('ğŸ“¡ Connexion Ã  MongoDB...');
mongoose.connect(MONGODB_URI, {
  useNewUrlParser: true,
  useUnifiedTopology: true
})
.then(() => {
  console.log('âœ… MongoDB connectÃ© avec succÃ¨s !');
  createDefaultAdmin();
})
.catch((err) => console.error('âŒ Erreur MongoDB:', err.message));

// Schemas
const userSchema = new mongoose.Schema({
  username: { type: String, required: true, unique: true },
  password: { type: String, required: true },
  isAdmin: { type: Boolean, default: false },
  createdAt: { type: Date, default: Date.now },
  badges: { type: [String], default: [] },
  stats: {
    totalExercises: { type: Number, default: 0 },
    perfectScores: { type: Number, default: 0 },
    consecutiveDays: { type: Number, default: 0 },
    lastLoginDate: { type: Date, default: null },
    totalWords: { type: Number, default: 0 },
    correctWords: { type: Number, default: 0 },
    simpleWordsCorrect: { type: Number, default: 0 },
    verbsCorrect: { type: Number, default: 0 },
    presentCorrect: { type: Number, default: 0 },
    futurCorrect: { type: Number, default: 0 },
    imparfaitCorrect: { type: Number, default: 0 },
    passeComposeCorrect: { type: Number, default: 0 },
    consecutiveCorrect: { type: Number, default: 0 },
    bestStreak: { type: Number, default: 0 }
  }
}, { versionKey: false }); // âœ… FIX: DÃ©sactive le versioning qui cause le problÃ¨me

const wordSchema = new mongoose.Schema({
  text: { type: String, required: true },
  type: { type: String, enum: ['simple', 'verb'], required: true },
  conjugation: { 
    type: String, 
    enum: ['present', 'futur', 'imparfait', 'passe_compose', null], 
    default: null 
  },
  conjugatedForms: {
    type: {
      je: { type: String, default: '' },
      tu: { type: String, default: '' },
      il: { type: String, default: '' },
      nous: { type: String, default: '' },
      vous: { type: String, default: '' },
      ils: { type: String, default: '' }
    },
    required: false,
    default: null
  },
  autoGenerated: { type: Boolean, default: false }
});

const exerciseSchema = new mongoose.Schema({
  name: { type: String, required: true },
  words: [wordSchema],
  createdBy: { type: String, required: true },
  createdAt: { type: Date, default: Date.now }
});

const scoreSchema = new mongoose.Schema({
  username: { type: String, required: true },
  exerciseName: { type: String, required: true },
  score: { type: Number, required: true },
  totalWords: { type: Number, required: true },
  correctWords: { type: Number, required: true },
  date: { type: Date, default: Date.now }
});

// Models
const User = mongoose.model('User', userSchema);
const Exercise = mongoose.model('Exercise', exerciseSchema);
const Score = mongoose.model('Score', scoreSchema);

// CrÃ©er un compte admin par dÃ©faut
async function createDefaultAdmin() {
  try {
    const adminExists = await User.findOne({ username: 'admin' });
    if (!adminExists) {
      const admin = new User({
        username: 'admin',
        password: 'admin123',
        isAdmin: true
      });
      await admin.save();
      console.log('âœ… Compte administrateur par dÃ©faut crÃ©Ã© (admin/admin123)');
    } else {
      console.log('â„¹ï¸ Compte administrateur dÃ©jÃ  existant');
    }
  } catch (error) {
    console.error('âŒ Erreur crÃ©ation admin par dÃ©faut:', error.message);
  }
}

// Routes

// Route de test
app.get('/', (req, res) => {
  res.json({ message: 'API Orthographe Game - Backend opÃ©rationnel !' });
});

// Users
app.post('/api/users/login', async (req, res) => {
  try {
    const { username, password } = req.body;
    
    if (!username || username.trim() === '') {
      return res.status(400).json({ error: 'Le nom d\'utilisateur est requis' });
    }
    
    if (!password || password.trim() === '') {
      return res.status(400).json({ error: 'Le mot de passe est requis' });
    }
    
    let user = await User.findOne({ username, password });
    
    if (!user) {
      return res.status(401).json({ error: 'Nom d\'utilisateur ou mot de passe incorrect' });
    }
    
    console.log(`ğŸ‘¤ Connexion utilisateur: ${username} (Admin: ${user.isAdmin})`);
    res.json(user);
  } catch (error) {
    console.error('âŒ Erreur login:', error.message);
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/users/create', async (req, res) => {
  try {
    const { username, password, isAdmin, createdBy } = req.body;
    
    if (!username || username.trim() === '') {
      return res.status(400).json({ error: 'Le nom d\'utilisateur est requis' });
    }
    
    if (!password || password.trim() === '') {
      return res.status(400).json({ error: 'Le mot de passe est requis' });
    }
    
    const existingUser = await User.findOne({ username });
    if (existingUser) {
      return res.status(409).json({ error: 'Ce nom d\'utilisateur existe dÃ©jÃ ' });
    }
    
    const user = new User({ 
      username, 
      password,
      isAdmin: isAdmin || false 
    });
    await user.save();
    console.log(`âœ… Nouvel utilisateur crÃ©Ã©: ${username} (Admin: ${isAdmin}) par ${createdBy}`);
    res.json(user);
  } catch (error) {
    console.error('âŒ Erreur crÃ©ation utilisateur:', error.message);
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/users', async (req, res) => {
  try {
    const users = await User.find();
    res.json(users);
  } catch (error) {
    console.error('âŒ Erreur rÃ©cupÃ©ration users:', error.message);
    res.status(500).json({ error: error.message });
  }
});

app.delete('/api/users/:id', async (req, res) => {
  try {
    await User.findByIdAndDelete(req.params.id);
    console.log(`ğŸ—‘ï¸ Utilisateur supprimÃ©: ${req.params.id}`);
    res.json({ message: 'Utilisateur supprimÃ©' });
  } catch (error) {
    console.error('âŒ Erreur suppression utilisateur:', error.message);
    res.status(500).json({ error: error.message });
  }
});

// Exercises
app.post('/api/exercises', async (req, res) => {
  try {
    const { name, words, createdBy } = req.body;
    
    if (!name || !words || words.length === 0) {
      return res.status(400).json({ error: 'Nom et mots requis' });
    }
    
    const exercise = new Exercise({ name, words, createdBy });
    await exercise.save();
    console.log(`âœ… Exercice crÃ©Ã©: ${name} (${words.length} mots)`);
    res.json(exercise);
  } catch (error) {
    console.error('âŒ Erreur crÃ©ation exercice:', error.message);
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/exercises', async (req, res) => {
  try {
    const exercises = await Exercise.find().sort({ createdAt: -1 });
    res.json(exercises);
  } catch (error) {
    console.error('âŒ Erreur rÃ©cupÃ©ration exercices:', error.message);
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/exercises/:id', async (req, res) => {
  try {
    const exercise = await Exercise.findById(req.params.id);
    if (!exercise) {
      return res.status(404).json({ error: 'Exercice non trouvÃ©' });
    }
    res.json(exercise);
  } catch (error) {
    console.error('âŒ Erreur rÃ©cupÃ©ration exercice:', error.message);
    res.status(500).json({ error: error.message });
  }
});

app.put('/api/exercises/:id', async (req, res) => {
  try {
    const { name, words } = req.body;
    
    if (!name || !words || words.length === 0) {
      return res.status(400).json({ error: 'Nom et mots requis' });
    }
    
    const exercise = await Exercise.findByIdAndUpdate(
      req.params.id,
      { name, words },
      { new: true }
    );
    console.log(`âœ… Exercice modifiÃ©: ${name} (${words.length} mots)`);
    res.json(exercise);
  } catch (error) {
    console.error('âŒ Erreur modification exercice:', error.message);
    res.status(500).json({ error: error.message });
  }
});

app.delete('/api/exercises/:id', async (req, res) => {
  try {
    await Exercise.findByIdAndDelete(req.params.id);
    console.log(`ğŸ—‘ï¸ Exercice supprimÃ©: ${req.params.id}`);
    res.json({ message: 'Exercice supprimÃ©' });
  } catch (error) {
    console.error('âŒ Erreur suppression exercice:', error.message);
    res.status(500).json({ error: error.message });
  }
});

// Scores - VERSION CORRIGÃ‰E
app.post('/api/scores', async (req, res) => {
  try {
    const { username, exerciseName, score, totalWords, correctWords, results } = req.body;
    
    if (!username || !exerciseName || score === undefined) {
      return res.status(400).json({ error: 'DonnÃ©es incomplÃ¨tes' });
    }
    
    // Sauvegarder le score
    const newScore = new Score({ 
      username, 
      exerciseName, 
      score, 
      totalWords, 
      correctWords 
    });
    await newScore.save();
    console.log(`âœ… Score sauvegardÃ© dans la base de donnÃ©es`);
    
    // âœ… FIX: Utiliser findOneAndUpdate au lieu de save() pour Ã©viter les conflits de version
    const user = await User.findOne({ username });
    if (user) {
      const updateData = {
        $inc: {
          'stats.totalExercises': 1,
          'stats.totalWords': totalWords,
          'stats.correctWords': correctWords
        }
      };
      
      // Incrementer perfectScores si score est 100
      if (score === 100) {
        updateData.$inc['stats.perfectScores'] = 1;
      }
      
      // Calculer les jours consÃ©cutifs
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const lastLogin = user.stats?.lastLoginDate ? new Date(user.stats.lastLoginDate) : null;
      
      let consecutiveDays = user.stats?.consecutiveDays || 0;
      if (lastLogin) {
        lastLogin.setHours(0, 0, 0, 0);
        const diffDays = Math.floor((today - lastLogin) / (1000 * 60 * 60 * 24));
        
        if (diffDays === 1) {
          consecutiveDays = consecutiveDays + 1;
        } else if (diffDays > 1) {
          consecutiveDays = 1;
        }
      } else {
        consecutiveDays = 1;
      }
      
      updateData.$set = {
        'stats.consecutiveDays': consecutiveDays,
        'stats.lastLoginDate': new Date()
      };
      
      // Analyser les rÃ©sultats dÃ©taillÃ©s
      if (results && Array.isArray(results)) {
        let simpleWordsCorrect = 0;
        let verbsCorrect = 0;
        let presentCorrect = 0;
        let futurCorrect = 0;
        let imparfaitCorrect = 0;
        let passeComposeCorrect = 0;
        let currentStreak = 0;
        let bestStreak = user.stats?.bestStreak || 0;
        
        results.forEach(result => {
          if (result.isCorrect) {
            currentStreak++;
            if (currentStreak > bestStreak) {
              bestStreak = currentStreak;
            }
            
            if (result.word?.type === 'simple') {
              simpleWordsCorrect++;
            } else if (result.word?.type === 'verb') {
              verbsCorrect++;
              
              switch(result.word?.conjugation) {
                case 'present': presentCorrect++; break;
                case 'futur': futurCorrect++; break;
                case 'imparfait': imparfaitCorrect++; break;
                case 'passe_compose': passeComposeCorrect++; break;
              }
            }
          } else {
            currentStreak = 0;
          }
        });
        
        updateData.$inc['stats.simpleWordsCorrect'] = simpleWordsCorrect;
        updateData.$inc['stats.verbsCorrect'] = verbsCorrect;
        updateData.$inc['stats.presentCorrect'] = presentCorrect;
        updateData.$inc['stats.futurCorrect'] = futurCorrect;
        updateData.$inc['stats.imparfaitCorrect'] = imparfaitCorrect;
        updateData.$inc['stats.passeComposeCorrect'] = passeComposeCorrect;
        
        if (bestStreak > (user.stats?.bestStreak || 0)) {
          updateData.$set['stats.bestStreak'] = bestStreak;
        }
      }
      
      // âœ… FIX: Mettre Ã  jour l'utilisateur avec findOneAndUpdate
      const updatedUser = await User.findOneAndUpdate(
        { username },
        updateData,
        { new: true }
      );
      
      // VÃ©rifier les nouveaux badges
      const newBadges = checkBadges(updatedUser);
      if (newBadges.length > 0) {
        // Ajouter les nouveaux badges
        await User.findOneAndUpdate(
          { username },
          { $addToSet: { badges: { $each: newBadges } } }
        );
        console.log(`ğŸ† ${newBadges.length} nouveau(x) badge(s) dÃ©bloquÃ©(s) pour ${username}`);
        return res.json({ score: newScore, newBadges });
      }
      
      console.log(`ğŸ“Š Stats mises Ã  jour pour ${username}`);
    }
    
    console.log(`ğŸ† Score enregistrÃ©: ${username} - ${score}% (${exerciseName})`);
    res.json({ score: newScore, newBadges: [] });
  } catch (error) {
    console.error('âŒ Erreur enregistrement score:', error.message);
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/scores', async (req, res) => {
  try {
    const scores = await Score.find().sort({ date: -1 });
    res.json(scores);
  } catch (error) {
    console.error('âŒ Erreur rÃ©cupÃ©ration scores:', error.message);
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/scores/user/:username', async (req, res) => {
  try {
    const scores = await Score.find({ username: req.params.username }).sort({ date: -1 });
    res.json(scores);
  } catch (error) {
    console.error('âŒ Erreur rÃ©cupÃ©ration scores utilisateur:', error.message);
    res.status(500).json({ error: error.message });
  }
});

// Fonction de dÃ©tection des badges
function checkBadges(user) {
  const newBadges = [];
  const stats = user.stats || {};
  const currentBadges = user.badges || [];
  
  // Badges de progression
  if (stats.totalExercises >= 1 && !currentBadges.includes('graine')) {
    newBadges.push('graine');
  }
  if (stats.totalExercises >= 5 && !currentBadges.includes('pousse')) {
    newBadges.push('pousse');
  }
  if (stats.totalExercises >= 20 && !currentBadges.includes('arbre')) {
    newBadges.push('arbre');
  }
  if (stats.totalExercises >= 50 && !currentBadges.includes('maitre')) {
    newBadges.push('maitre');
  }
  if (stats.totalExercises >= 100 && !currentBadges.includes('empereur')) {
    newBadges.push('empereur');
  }
  
  // Badges de performance
  if (stats.totalExercises >= 1 && !currentBadges.includes('etoile1')) {
    newBadges.push('etoile1');
  }
  if (stats.perfectScores >= 1 && !currentBadges.includes('sansfaute')) {
    newBadges.push('sansfaute');
  }
  if (stats.perfectScores >= 5 && !currentBadges.includes('tireur')) {
    newBadges.push('tireur');
  }
  if (stats.perfectScores >= 10 && !currentBadges.includes('perfection')) {
    newBadges.push('perfection');
  }
  
  // Badges de persÃ©vÃ©rance
  if (stats.consecutiveDays >= 2 && !currentBadges.includes('flamme1')) {
    newBadges.push('flamme1');
  }
  if (stats.consecutiveDays >= 5 && !currentBadges.includes('flamme2')) {
    newBadges.push('flamme2');
  }
  if (stats.consecutiveDays >= 10 && !currentBadges.includes('flamme3')) {
    newBadges.push('flamme3');
  }
  if (stats.consecutiveDays >= 7 && !currentBadges.includes('arcenciel')) {
    newBadges.push('arcenciel');
  }
  if (stats.consecutiveDays >= 30 && !currentBadges.includes('foudre')) {
    newBadges.push('foudre');
  }
  
  // Badges spÃ©cialisÃ©s
  if (stats.simpleWordsCorrect >= 20 && !currentBadges.includes('roimots')) {
    newBadges.push('roimots');
  }
  if (stats.verbsCorrect >= 20 && !currentBadges.includes('jongleur')) {
    newBadges.push('jongleur');
  }
  if (stats.presentCorrect >= 10 && !currentBadges.includes('acrobate')) {
    newBadges.push('acrobate');
  }
  if (stats.presentCorrect >= 5 && stats.futurCorrect >= 5 && 
      stats.imparfaitCorrect >= 5 && stats.passeComposeCorrect >= 5 && 
      !currentBadges.includes('voyageur')) {
    newBadges.push('voyageur');
  }
  
  // Badges de dÃ©fi
  if (stats.bestStreak >= 100 && !currentBadges.includes('cerveau')) {
    newBadges.push('cerveau');
  }
  
  return newBadges;
}

// MÃ©tadonnÃ©es des badges
const badgeMetadata = {
  graine: { name: 'ğŸŒ± Graine d\'orthographe', description: 'Premier exercice rÃ©ussi' },
  pousse: { name: 'ğŸŒ¿ Pousse prometteuse', description: '5 exercices rÃ©ussis' },
  arbre: { name: 'ğŸŒ³ Arbre de la connaissance', description: '20 exercices rÃ©ussis' },
  maitre: { name: 'ğŸ† MaÃ®tre des mots', description: '50 exercices rÃ©ussis' },
  empereur: { name: 'ğŸ‘‘ Empereur de l\'orthographe', description: '100 exercices rÃ©ussis' },
  
  etoile1: { name: 'â­ PremiÃ¨re Ã©toile', description: 'Terminer un exercice' },
  sansfaute: { name: 'âœ¨ Sans faute !', description: 'Premier score de 100%' },
  tireur: { name: 'ğŸ¯ Tireur d\'Ã©lite', description: '5 exercices Ã  100%' },
  perfection: { name: 'ğŸ’ Perfection incarnÃ©e', description: '10 exercices Ã  100%' },
  
  flamme1: { name: 'ğŸ”¥ PremiÃ¨re flamme', description: '2 jours consÃ©cutifs' },
  flamme2: { name: 'ğŸ”¥ğŸ”¥ SÃ©rie en feu', description: '5 jours consÃ©cutifs' },
  flamme3: { name: 'ğŸ”¥ğŸ”¥ğŸ”¥ Incendie de motivation', description: '10 jours consÃ©cutifs' },
  arcenciel: { name: 'ğŸŒˆ Arc-en-ciel', description: '7 jours d\'affilÃ©e' },
  foudre: { name: 'âš¡ Foudre d\'Ã©nergie', description: '30 jours consÃ©cutifs' },
  
  roimots: { name: 'ğŸ“– Roi des mots simples', description: '20 mots simples parfaits' },
  jongleur: { name: 'ğŸ­ Jongleur de verbes', description: '20 verbes parfaits' },
  acrobate: { name: 'ğŸª Acrobate du prÃ©sent', description: '10 verbes au prÃ©sent parfaits' },
  voyageur: { name: 'â° Voyageur du temps', description: 'MaÃ®triser tous les temps' },
  
  cerveau: { name: 'ğŸ§  Cerveau d\'acier', description: '100 mots corrects d\'affilÃ©e' }
};

app.get('/api/badges/metadata', (req, res) => {
  res.json(badgeMetadata);
});

// DÃ©marrage du serveur
const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
  console.log(`âœ… Serveur dÃ©marrÃ© sur le port ${PORT}`);
  console.log(`ğŸŒ API disponible sur http://localhost:${PORT}/api`);
  console.log(`ğŸ“ Test: http://localhost:${PORT}/`);
});